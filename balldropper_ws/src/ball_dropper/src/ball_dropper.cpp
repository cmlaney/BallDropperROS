/*
 * Author: Evan Beachly
 * Date: August 30, 2015
 * Description: Code for receiving joystick commands over serial
 *
 * CRC Table generated by code found here:
 * http://www.ross.net/crc/download/crc_v3.txt
 *
 */

#include "ros/ros.h"
#include "geometry_msgs/Twist.h"
#include "std_msgs/UInt8.h"
#include "ball_dropper/Heartbeat.h"
#include "ball_dropper/String.h"
#include "ball_dropper/Configuration.h"
#include "ball_dropper/Operation.h"
#include "ball_dropper/Configure.h"
#include "ball_dropper/GetConfiguration.h"
#include "ball_dropper/GetErrorString.h"
#include "rdt.hpp"
#include "boost/date_time/posix_time/posix_time.hpp"
#include "boost/thread.hpp"
#include "boost/interprocess/sync/scoped_lock.hpp"

#define OP_IDLE 0
#define OP_OPEN_HATCH 1
#define OP_CLOSE_HATCH 2
#define OP_ROTATE 3
#define OP_DRIVE_ON 4
#define OP_DRIVE_OFF 5
#define OP_INJECT 6
#define OP_RELOAD 7
#define OP_FLUSH 8
#define OP_CALIBRATE 100
#define OP_GET_ERROR_STRING 101
#define OP_CLEAR_ERRORS 102
#define OP_SET 103
#define OP_GET_CONFIGURATION 104
#define OP_EMG_STOP 255

#define OP_SET_ROTATE_COUNTER               0x01
#define OP_SET_DRIVE_COUNTER                0x02
#define OP_SET_INJECT_COUNTER               0x04
#define OP_SET_ROTATE_THRESHOLD             0x11
#define OP_SET_DRIVE_ON_THRESHOLD           0x12
#define OP_SET_DRIVE_OFF_THRESHOLD          0x13
#define OP_SET_INJECT_THRESHOLD             0x14
#define OP_SET_ROTATE_TIMEOUT               0x21
#define OP_SET_DRIVE_ON_TIMEOUT             0x22
#define OP_SET_DRIVE_OFF_TIMEOUT            0x23
#define OP_SET_INJECT_TIMEOUT               0x24
#define OP_SET_ROTATE_MAX_CURRENT           0x31
#define OP_SET_DRIVE_ON_MAX_CURRENT         0x32
#define OP_SET_DRIVE_OFF_MAX_CURRENT        0x33
#define OP_SET_INJECT_MAX_CURRENT           0x34
#define OP_SET_ROTATE_STALL_CHECK_ENABLE    0x41
#define OP_SET_DRIVE_ON_STALL_CHECK_ENABLE  0x42
#define OP_SET_DRIVE_OFF_STALL_CHECK_ENABLE 0x43
#define OP_SET_INJECT_STALL_CHECK_ENABLE    0x44

std::auto_ptr<Serial> serialPort;

boost::mutex receivedMsgsMtx;
const Packet* transmittedPacket = NULL;
bool acked = false;
ball_dropper::String global_stringMsg;
ball_dropper::Configuration global_configurationMsg;
ball_dropper::Heartbeat global_heartbeatMsg;

boost::mutex operationMtx;
ros::Publisher heartbeatPub;
ros::Publisher configurationPub;
ros::Publisher stringMessagePub;

void printStatus(ball_dropper::Heartbeat heartbeatMsg)
{
    printf("\nOp Code: %u\n", heartbeatMsg.currentOpCode);
    printf("\nOp Code of Last Action: %u\n", heartbeatMsg.opCodeOfLastAction);
    printf("Remaining Injections: %d\n", heartbeatMsg.remainingInjections);
    heartbeatMsg.calibrated ? printf("Calibrated\n") : printf("Uncalibrated\n");
    if (heartbeatMsg.hatchOpen) {
        printf("Hatch Open\n");
    } else {
        printf("Hatch Closed\n");
    }

    heartbeatMsg.wheelInPosition ? printf("Wheel in Position\n") : printf("Wheel not in Position!\n");

    if (heartbeatMsg.driverForward) {
        printf("Driver Forward\n");
    } else if (heartbeatMsg.driverBack) {
        printf("Driver Back\n");
    } else {
        printf("Driver neither Forward nor Back!\n");
    }

    if (heartbeatMsg.criticalFireDanger)
    {
        printf("System failure during injection! Critical Fire Danger!\n");
    }
    else if (heartbeatMsg.fireDanger)
    {
        printf("Ball is going to be on fire.\n");
    }

    if (heartbeatMsg.hatchFailure) {
        printf("Hatch Failure!\n");
    }
    if (heartbeatMsg.wheelFailure) {
        printf("Wheel Failure!\n");
    }
    if (heartbeatMsg.driverFailure) {
        printf("Driver Failure!\n");
    }
    if (heartbeatMsg.injectorFailure) {
        printf("Injector Failure!\n");
    }
    printf("Action Start Time: %u\n", heartbeatMsg.actionStartTime);
    printf("Action Duration: %u\n", heartbeatMsg.actionDuration);
    printf("Counter Start Val: %u\n", heartbeatMsg.counterStartVal);
    printf("Counter End Val: %u\n", heartbeatMsg.counterEndVal);
    printf("Lowest Current: %u\n", heartbeatMsg.lowestCurrent);
    printf("Highest Current: %u\n", heartbeatMsg.highestCurrent);
    printf("Total Current: %u\n", heartbeatMsg.totalCurrent);
    return;
}



/*
 * Commands the ball dropper to perform the requested operation
 */
bool operation(ball_dropper::Operation::Request &req,
                ball_dropper::Operation::Response &res)
{
    //Lock the mutex so that we don't try concurrent operations
    //Will be unlocked when the function returns and this object is destroyed
    boost::interprocess::scoped_lock<boost::mutex> slock(operationMtx);

    //Initialize the result
    res.communicationFailure = true;

    //Get the previous operation start time
    receivedMsgsMtx.lock();
    uint32_t previousActionStartTime = global_heartbeatMsg.actionStartTime;
    receivedMsgsMtx.unlock();

    bool success = false;
    //For each available attempt
    for (int attemptCount = 0; attemptCount < 1; ++attemptCount)
    {
        //Transmit the packet
        acked = false;
        if (attemptCount == 0)
        {
            transmittedPacket = transmitPacket(&(req.opCode), 1, serialPort.get());
        }
        else
        {
            transmittedPacket = retryTransmission(serialPort.get());
        }

        //Wait for timeout, acknowledgement, or infer communication success from the heartbeat
        ros::Time startWaitTime = ros::Time::now();
        ros::Duration waitTime;
        while (waitTime = ros::Time::now() - startWaitTime, waitTime.toSec() < 0.75)
        {
            receivedMsgsMtx.lock();
            uint32_t currentActionStartTime = global_heartbeatMsg.actionStartTime;
            uint8_t currentlastActionOpCode = global_heartbeatMsg.opCodeOfLastAction;
            receivedMsgsMtx.unlock();
            if ( acked ||
                previousActionStartTime != currentActionStartTime && currentlastActionOpCode == req.opCode)
            {
                success = true;
                res.communicationFailure = false;
                //Return
                acked = true;
                return true;
            }
        }
        acked = true;
    }
    //Return
    return true;
}

bool getErrorString(ball_dropper::GetErrorString::Request &req,
                    ball_dropper::GetErrorString::Response &res)
{
    //Lock the mutex so that we don't try concurrent operations
    //Will be unlocked when the function returns and this object is destroyed
    boost::interprocess::scoped_lock<boost::mutex> slock(operationMtx);

    //Initialize the result
    res.communicationFailure = true;
    res.errorStr = std::string("");

    //Get the time of the previous string message
    receivedMsgsMtx.lock();
    ros::Time timeOfPreviousMessage = global_stringMsg.header.stamp;
    receivedMsgsMtx.unlock();

    //The message to transmit
    uint8_t opCode = OP_GET_ERROR_STRING;

    //For each available attempt
    for (int attemptCount = 0; attemptCount < 1; ++attemptCount)
    {
        //Transmit the packet
        if (attemptCount == 0)
        {
            transmittedPacket = transmitPacket(&opCode, 1, serialPort.get());
        }
        else
        {
            transmittedPacket = retryTransmission(serialPort.get());
        }

        //Wait for a string to be received
        ros::Time startWaitTime = ros::Time::now();
        ros::Duration waitTime;
        while (waitTime = ros::Time::now() - startWaitTime, waitTime.toSec() < 1.0)
        {
            receivedMsgsMtx.lock();
            ros::Time timeOfCurrentMessage = global_stringMsg.header.stamp;
            receivedMsgsMtx.unlock();
            if (timeOfCurrentMessage.toSec() != timeOfPreviousMessage.toSec()) {
                res.communicationFailure = false;
                res.errorStr = global_stringMsg.str;
                return true;
            }
        }
    }
    return true;
}

/*
 * Commands the ball dropper to set the requested variable
 */
bool configure(ball_dropper::Configure::Request &req,
                ball_dropper::Configure::Response &res)
{
    //Lock the mutex so that we don't try concurrent operations
    //Will be unlocked when the function returns and this object is destroyed
    boost::interprocess::scoped_lock<boost::mutex> slock(operationMtx);

    //Initialize the result
    res.communicationFailure = true;

    uint8_t data[6];
    data[0] = OP_SET;
    data[1] = req.varCode;
    writeUint32(data,2,req.val);

    //For each available attempt
    for (int attemptCount = 0; attemptCount < 1; ++attemptCount)
    {
        //Transmit the packet
        acked = false;
        if (attemptCount == 0)
        {
            transmittedPacket = transmitPacket(data, 6, serialPort.get());
        }
        else
        {
            transmittedPacket = retryTransmission(serialPort.get());
        }

        //Wait for timeout or acknowledgement
        ros::Time startWaitTime = ros::Time::now();
        ros::Duration waitTime;
        while (waitTime = ros::Time::now() - startWaitTime, waitTime.toSec() < 0.75)
        {
            if (acked) {
                res.communicationFailure = false;
                return true;
            }
        }
        acked = true;
    }
    //Return
    return true;
}

bool getConfiguration(ball_dropper::GetConfiguration::Request &req,
                      ball_dropper::GetConfiguration::Response &res)
{
    //Lock the mutex so that we don't try concurrent operations
    //Will be unlocked when the function returns and this object is destroyed
    boost::interprocess::scoped_lock<boost::mutex> slock(operationMtx);
    
    //Initialize the result
    res.communicationFailure = true;
    res.rotateCounter = 0;
    res.driveCounter = 0;
    res.injectCounter = 0;
    res.rotateThresh = 0;
    res.driveOnThresh = 0;
    res.driveOffThresh = 0;
    res.injectThresh = 0;
    res.rotateTimeout = 0;
    res.driveOnTimeout = 0;
    res.driveOffTimeout = 0;
    res.injectTimeout = 0;
    res.rotateMaxCurrent = 0;
    res.driveOnMaxCurrent = 0;
    res.driveOffMaxCurrent = 0;
    res.injectMaxCurrent = 0;
    res.rotateStallCheckEnable = 0;
    res.driveOnStallCheckEnable = 0;
    res.driveOffStallCheckEnable = 0;
    res.injectStallCheckEnable = 0;

    //Get the time of the previous configuration message
    receivedMsgsMtx.lock();
    ros::Time timeOfPreviousMessage = global_configurationMsg.header.stamp;
    receivedMsgsMtx.unlock();

    //The message to transmit
    uint8_t opCode = OP_GET_CONFIGURATION;

    //For each available attempt
    for (int attemptCount = 0; attemptCount < 1; ++attemptCount)
    {
        //Transmit the packet
        if (attemptCount == 0)
        {
            transmittedPacket = transmitPacket(&opCode, 1, serialPort.get());
        }
        else
        {
            transmittedPacket = retryTransmission(serialPort.get());
        }

        //Wait for a configuration to be received
        ros::Time startWaitTime = ros::Time::now();
        ros::Duration waitTime;
        while (waitTime = ros::Time::now() - startWaitTime, waitTime.toSec() < 1.0)
        {
            receivedMsgsMtx.lock();
            ros::Time timeOfCurrentMessage = global_configurationMsg.header.stamp;
            receivedMsgsMtx.unlock();
            if (timeOfCurrentMessage.toSec() != timeOfPreviousMessage.toSec())
            {
                res.communicationFailure = false;
                res.rotateCounter = global_configurationMsg.rotateCounter;
                res.driveCounter = global_configurationMsg.driveCounter;
                res.injectCounter = global_configurationMsg.injectCounter;
                res.rotateThresh = global_configurationMsg.rotateThresh;
                res.driveOnThresh = global_configurationMsg.driveOnThresh;
                res.driveOffThresh = global_configurationMsg.driveOffThresh;
                res.injectThresh = global_configurationMsg.injectThresh;
                res.rotateTimeout = global_configurationMsg.rotateTimeout;
                res.driveOnTimeout = global_configurationMsg.driveOnTimeout;
                res.driveOffTimeout = global_configurationMsg.driveOffTimeout;
                res.injectTimeout = global_configurationMsg.injectTimeout;
                res.rotateMaxCurrent = global_configurationMsg.rotateMaxCurrent;
                res.driveOnMaxCurrent = global_configurationMsg.driveOnMaxCurrent;
                res.driveOffMaxCurrent = global_configurationMsg.driveOffMaxCurrent;
                res.injectMaxCurrent = global_configurationMsg.injectMaxCurrent;
                res.rotateStallCheckEnable = global_configurationMsg.rotateStallCheckEnable;
                res.driveOnStallCheckEnable = global_configurationMsg.driveOnStallCheckEnable;
                res.driveOffStallCheckEnable = global_configurationMsg.driveOffStallCheckEnable;
                res.injectStallCheckEnable = global_configurationMsg.injectStallCheckEnable;
                return true;
            }
        }
    }
    return true;
}

/*
 * @brief Dissects a configuration packet received from the ball dropper over the serial comms.
 */
ball_dropper::Configuration parseConfigurationPacket(const uint8_t* data)
{
    ball_dropper::Configuration configurationMsg;
    int offset = 0;

    configurationMsg.header.stamp = ros::Time::now();

    configurationMsg.rotateCounter = readUint32(data, offset);
    offset+=4;
    configurationMsg.driveCounter = readUint32(data, offset);
    offset+=4;
    configurationMsg.injectCounter = readUint32(data, offset);
    offset+=4;

    configurationMsg.rotateThresh = readUint32(data, offset);
    offset+=4;
    configurationMsg.driveOnThresh = readUint32(data, offset);
    offset+=4;
    configurationMsg.driveOffThresh = readUint32(data, offset);
    offset+=4;
    configurationMsg.injectThresh = readUint32(data, offset);
    offset+=4;

    configurationMsg.rotateTimeout = readUint16(data, offset);
    offset+=2;
    configurationMsg.driveOnTimeout = readUint16(data, offset);
    offset+=2;
    configurationMsg.driveOffTimeout = readUint16(data, offset);
    offset+=2;
    configurationMsg.injectTimeout = readUint16(data, offset);
    offset+=2;

    configurationMsg.rotateMaxCurrent = readUint16(data, offset);
    offset+=2;
    configurationMsg.driveOnMaxCurrent = readUint16(data, offset);
    offset+=2;
    configurationMsg.driveOffMaxCurrent = readUint16(data, offset);
    offset+=2;
    configurationMsg.injectMaxCurrent = readUint16(data, offset);
    offset+=2;

    configurationMsg.rotateStallCheckEnable = (data[offset] & 0x01);
    configurationMsg.driveOnStallCheckEnable = (data[offset] & 0x02) >> 1;
    configurationMsg.driveOffStallCheckEnable = (data[offset] & 0x04) >> 2;
    configurationMsg.injectStallCheckEnable = (data[offset] & 0x08) >> 3;
    offset+=1;
    
    return configurationMsg;
}

ball_dropper::String parseStringPacket(const uint8_t* data)
{
    ball_dropper::String stringMsg;
    stringMsg.header.stamp = ros::Time::now();
    stringMsg.str = std::string((char*)data);
    return stringMsg;
}

ball_dropper::Heartbeat parseHeartbeatPacket( const uint8_t* data)
{
    ball_dropper::Heartbeat heartbeatMsg;
    int offset = 0;
    uint8_t flags = 0;

    heartbeatMsg.header.stamp = ros::Time::now();

    heartbeatMsg.currentOpCode = data[offset];
    ++offset;

    heartbeatMsg.opCodeOfLastAction = data[offset];
    ++offset;

    heartbeatMsg.remainingInjections = data[offset];
    ++offset;

    heartbeatMsg.calibrated = (data[offset] & 0x01);
    heartbeatMsg.hatchOpen  = (data[offset] & 0x02) >> 1;
    heartbeatMsg.wheelInPosition = (data[offset] & 0x04) >> 2;
    heartbeatMsg.driverForward = (data[offset] & 0x08) >> 3;
    heartbeatMsg.driverBack = (data[offset] & 0x10) >> 4;
    heartbeatMsg.fireDanger = (data[offset] & 0x20) >> 5;
    heartbeatMsg.criticalFireDanger = (data[offset] & 0x40) >> 6;
    ++offset;

    heartbeatMsg.hatchFailure = (data[offset] & 0x01);
    heartbeatMsg.wheelFailure = (data[offset] & 0x02) >> 1;
    heartbeatMsg.driverFailure = (data[offset] & 0x04) >> 2;
    heartbeatMsg.injectorFailure = (data[offset] & 0x08) >> 3;
    heartbeatMsg.rotateMotorOn = (data[offset] & 0x10) >> 4;
    heartbeatMsg.driveMotorOn = (data[offset] & 0x20) >> 5;
    heartbeatMsg.injectMotorOn = (data[offset] & 0x40) >> 6;
    ++offset;

    heartbeatMsg.batteryVoltage = readUint32(data,offset);
    offset+=4;

    heartbeatMsg.actionStartTime = readUint32(data,offset);
    offset+=4;

    heartbeatMsg.actionDuration = readUint32(data,offset);
    offset+=4;

    heartbeatMsg.counterStartVal = readUint32(data,offset);
    offset+=4;

    heartbeatMsg.counterEndVal = readUint32(data,offset);
    offset+=4;

    heartbeatMsg.instantaneousCurrent = readUint16(data,offset);
    offset+=2;

    heartbeatMsg.lowestCurrent = readUint16(data,offset);
    offset+=2;

    heartbeatMsg.highestCurrent = readUint16(data,offset);
    offset+=2;

    heartbeatMsg.totalCurrent = readUint32(data,offset);
    offset+=4;

    return heartbeatMsg;
}

void listenerThread(void)
{
    const Packet* receivedPkt;
    int expectedSequenceNum = -1;
    int numReceivedPackets = 0;
    int numDroppedPackets = 0;

    //Run until interrupted
    ros::Rate r(60);
    ros::Time timeOfLastHeartbeat = ros::Time::now();
    while (ros::ok())
    {
        receivedPkt = checkForPacket(serialPort.get());
        if (receivedPkt != NULL)
        {
            if ( !isAck(receivedPkt) )
            {
                receivedMsgsMtx.lock();
                ++numReceivedPackets;
                //Check if we've lost any packets
                if (expectedSequenceNum != -1)
                {
                    while (expectedSequenceNum != receivedPkt->sequenceId)
                    {
                        //printf("Dropped packet %d\n", expectedSequenceNum);
                        expectedSequenceNum =  0xFF & (expectedSequenceNum + 1);
                        ++numDroppedPackets;
                    }
                }
                expectedSequenceNum = 0xFF & (receivedPkt->sequenceId + 1);

                //Compute communication percentage
                double totalPackets = numDroppedPackets + numReceivedPackets;
                //printf("Communication Rate: %f%%\n", (double) numReceivedPackets / totalPackets);

                //Is this a string packet?
                if (receivedPkt->data[receivedPkt->dataLength - 1] == '\0')
                {
                    global_stringMsg = parseStringPacket(receivedPkt->data);
                    stringMessagePub.publish(global_stringMsg);
                }
                //Is this a heartbeat packet?
                else if (receivedPkt->dataLength == 36)
                {
                    global_heartbeatMsg = parseHeartbeatPacket(receivedPkt->data);
                    heartbeatPub.publish(global_heartbeatMsg);
                    //Heartbeat packet
                    //printf("Heartbeat Packet Received\n");
                    //parseHeartbeatPacket(receivedPkt->data);

                    double timeSinceLastHeartbeat = (ros::Time::now() - timeOfLastHeartbeat).toSec();

                    if (timeSinceLastHeartbeat > 0.3)
                    {
                        std::cout << timeSinceLastHeartbeat << std::endl;
                        printf("Communication Rate: %f%%\n", (double) numReceivedPackets / totalPackets);
                    }

                    //std::cout << (ros::Time::now() - timeOfLastHeartbeat).toSec() << std::endl;
                    timeOfLastHeartbeat = ros::Time::now();
                }
                else if (receivedPkt->dataLength == 46)
                {
                    global_configurationMsg = parseConfigurationPacket(receivedPkt->data);
                    configurationPub.publish(global_configurationMsg);
                }
                //This must be some unrecognized binary data packet.
                else
                {
                    printf("Unknown packet type received. Length = %u\n", receivedPkt->dataLength);
                }
                receivedMsgsMtx.unlock();
            }
            else
            {
                //printf("Ack SeqID: %u, CRC16: %u received\n", receivedPkt->sequenceId, receivedPkt->crc16 );
                //Is this ack acking a packet we sent?
                if (!acked && transmittedPacket != NULL && isAcking(transmittedPacket, receivedPkt))
                {
                    acked = true;
                }
            }
        }
        r.sleep();
    }
}

//Main
int main(int argc, char **argv)
{
    //Create a node
    ros::init(argc, argv, "ball_dropper_node");
    ros::NodeHandle n;

    setMaxAllowedDataLength(46);

    std::string serialDevice;
    int baud;

    //Get the name of the serial device to open
    n.param<std::string>("/" + ros::this_node::getName() + "/serialDevice", serialDevice, "/dev/ttyUSB0");
    n.param<int>("/" + ros::this_node::getName() + "/baud", baud, 9600);

    serialPort.reset(new Serial(serialDevice, baud));

    heartbeatPub = n.advertise<ball_dropper::Heartbeat>("heartbeat", 100);
    configurationPub = n.advertise<ball_dropper::Configuration>("configuration", 100);
    stringMessagePub = n.advertise<ball_dropper::String>("stringMessages", 100);
    ros::ServiceServer operationService = n.advertiseService("operation", operation);
    ros::ServiceServer getConfigurationService = n.advertiseService("getConfiguration", getConfiguration);
    ros::ServiceServer getErrorStringService = n.advertiseService("getErrorString", getErrorString);
    ros::ServiceServer configureService = n.advertiseService("configure", configure);

    std::auto_ptr<boost::thread> pListenerThread;
    //Create a new thread to listen on the serial port.
    pListenerThread.reset( new boost::thread(listenerThread));

    //Handle subscriber and service server callbacks in this thread
    ros::spin(); 

    pListenerThread->join();

    return 0;
}

