/*
 * Author: Evan Beachly
 * Date: August 30, 2015
 * Description: Code for receiving joystick commands over serial
 *
 * CRC Table generated by code found here:
 * http://www.ross.net/crc/download/crc_v3.txt
 *
 */

#include "ros/ros.h"
#include "geometry_msgs/Twist.h"
#include "std_msgs/String.h"
#include "std_msgs/UInt8.h"
#include "ball_dropper_msgs/Heartbeat.h"
#include "ball_dropper/Operation.h"
#include "rdt.hpp"
#include "boost/date_time/posix_time/posix_time.hpp"
#include "boost/thread.hpp"
#include "boost/interprocess/sync/scoped_lock.hpp"

#define OP_IDLE 0
#define OP_OPEN_HATCH 1
#define OP_CLOSE_HATCH 2
#define OP_ROTATE 3
#define OP_DRIVE_ON 4
#define OP_DRIVE_OFF 5
#define OP_INJECT 6
#define OP_RELOAD 7
#define OP_FLUSH 8
#define OP_CALIBRATE 100
#define OP_GET_ERROR_STRING 101
#define OP_CLEAR_ERRORS 102
#define OP_EMG_STOP 255

std::auto_ptr<Serial> serialPort;

ros::Time timestamp;
uint8_t opCode;
uint8_t opCodeOfLastAction;
uint8_t remainingInjections = 0;
bool calibrated = false;
bool hatchOpen = false;
bool wheelInPosition = false;
bool driverForward = false;
bool driverBack = false;
bool fireDanger = false;
bool criticalFireDanger = false;
bool rotateMotorOn = false;
bool driveMotorOn = false;
bool injectMotorOn = false;
bool hatchFailure = false;
bool wheelFailure = false;
bool driverFailure = false;
bool injectorFailure = false;
uint32_t batteryVoltage;
uint32_t actionStartTime;
uint32_t actionDuration;
uint32_t counterStartVal;
uint32_t counterEndVal;
uint16_t instantaneousCurrent;
uint16_t lowestCurrent;
uint16_t highestCurrent;
uint32_t totalCurrent;

ros::Publisher heartbeatPub;
void publishHeartbeatMsg()
{
    ball_dropper_msgs::Heartbeat heartbeatMsg;

    heartbeatMsg.header.stamp = timestamp;

    heartbeatMsg.currentOpCode = opCode;
    heartbeatMsg.opCodeOfLastAction = opCodeOfLastAction;
    heartbeatMsg.remainingInjections = remainingInjections;
    heartbeatMsg.calibrated = calibrated ? 1 : 0;
    heartbeatMsg.hatchOpen = hatchOpen ? 1 : 0;
    heartbeatMsg.wheelInPosition = wheelInPosition ? 1 : 0;
    heartbeatMsg.driverForward = driverForward? 1 : 0;
    heartbeatMsg.driverBack = driverBack ? 1 : 0;
    heartbeatMsg.fireDanger = fireDanger ? 1 : 0;
    heartbeatMsg.criticalFireDanger = criticalFireDanger ? 1 : 0;
    heartbeatMsg.hatchFailure = hatchFailure ? 1 : 0;
    heartbeatMsg.wheelFailure = wheelFailure ? 1 : 0;
    heartbeatMsg.driverFailure = driverFailure ? 1 : 0;
    heartbeatMsg.injectorFailure = injectorFailure ? 1 : 0;
    heartbeatMsg.rotateMotorOn = rotateMotorOn ? 1 : 0;
    heartbeatMsg.driveMotorOn = driveMotorOn ? 1 : 0;
    heartbeatMsg.injectMotorOn = injectMotorOn ? 1 : 0;
    heartbeatMsg.batteryVoltage = batteryVoltage;
    heartbeatMsg.actionStartTime = actionStartTime;
    heartbeatMsg.actionDuration = actionDuration;
    heartbeatMsg.counterStartVal = counterStartVal;
    heartbeatMsg.counterEndVal = counterEndVal;
    heartbeatMsg.instantaneousCurrent = instantaneousCurrent;
    heartbeatMsg.lowestCurrent = lowestCurrent;
    heartbeatMsg.highestCurrent = highestCurrent;
    heartbeatMsg.totalCurrent = totalCurrent;

    heartbeatPub.publish(heartbeatMsg);
}

void printStatus()
{
    printf("\nOp Code: %u\n", opCode);
    printf("\nOp Code of Last Action: %u\n", opCode);
    printf("Remaining Injections: %d\n", remainingInjections);
    calibrated ? printf("Calibrated\n") : printf("Uncalibrated\n");
    if (hatchOpen) {
        printf("Hatch Open\n");
    } else {
        printf("Hatch Closed\n");
    }

    wheelInPosition ? printf("Wheel in Position\n") : printf("Wheel not in Position!\n");

    if (driverForward) {
        printf("Driver Forward\n");
    } else if (driverBack) {
        printf("Driver Back\n");
    } else {
        printf("Driver neither Forward nor Back!\n");
    }

    if (criticalFireDanger)
    {
        printf("System failure during injection! Critical Fire Danger!\n");
    }
    else if (fireDanger)
    {
        printf("Ball is going to be on fire.\n");
    }

    if (hatchFailure) {
        printf("Hatch Failure!\n");
    }
    if (wheelFailure) {
        printf("Wheel Failure!\n");
    }
    if (driverFailure) {
        printf("Driver Failure!\n");
    }
    if (injectorFailure) {
        printf("Injector Failure!\n");
    }
    printf("Action Start Time: %u\n", actionStartTime);
    printf("Action Duration: %u\n", actionDuration);
    printf("Counter Start Val: %u\n", counterStartVal);
    printf("Counter End Val: %u\n", counterEndVal);
    printf("Lowest Current: %u\n", lowestCurrent);
    printf("Highest Current: %u\n", highestCurrent);
    printf("Total Current: %u\n", totalCurrent);
}

/*
 * @brief Dissects a status packet received from the ball dropper over the serial comms.
 */
void parseHeartbeatPacket(const uint8_t* data)
{
    int offset = 0;
    uint8_t flags;

    timestamp = ros::Time::now();

    opCode = data[offset];
    ++offset;

    opCodeOfLastAction = data[offset];
    ++offset;

    remainingInjections = data[offset];
    ++offset;

    flags = data[offset];
    calibrated = flags & 0x01 ? true : false;
    hatchOpen  = flags & 0x02 ? true : false;
    wheelInPosition = flags & 0x04 ? true : false;
    driverForward = flags & 0x08 ? true : false;
    driverBack = flags & 0x10 ? true : false;
    fireDanger = flags & 0x20 ? true : false;
    criticalFireDanger = flags & 0x40 ? true : false;
    ++offset;

    flags = data[offset];
    hatchFailure = flags & 0x01 ? true : false;
    wheelFailure = flags & 0x02 ? true : false;
    driverFailure = flags & 0x04 ? true : false;
    injectorFailure = flags & 0x08 ? true : false;
    rotateMotorOn = flags & 0x10 ? true : false;
    driveMotorOn = flags & 0x20 ? true : false;
    injectMotorOn = flags & 0x40 ? true : false;
    ++offset;

    batteryVoltage = readUint32(data,offset);
    offset+=4;

    actionStartTime = readUint32(data,offset);
    offset+=4;

    actionDuration = readUint32(data,offset);
    offset+=4;

    counterStartVal = readUint32(data,offset);
    offset+=4;

    counterEndVal = readUint32(data,offset);
    offset+=4;

    instantaneousCurrent = readUint16(data,offset);
    offset+=2;

    lowestCurrent = readUint16(data,offset);
    offset+=2;

    highestCurrent = readUint16(data,offset);
    offset+=2;

    totalCurrent = readUint32(data,offset);
    offset+=4;

    publishHeartbeatMsg();
    return;
}


//Transmit any string recieved to the ball dropper
void consoleCallback(const std_msgs::String& msg)
{
    if ( msg.data.length() < 255 )
    {
        transmitStringPacket(msg.data.c_str(), serialPort.get());
    }
}

const Packet* transmittedPacket = NULL;
bool acked = false;
bool expectingErrorString = false;
char errorString[256];
boost::mutex operationMtx;

/*
 * Commands the ball dropper to perform the requested operation
 */
bool operation(ball_dropper::Operation::Request &req,
                ball_dropper::Operation::Response &res)
{
    //Lock the mutex so that we don't try concurrent operations
    //Will be unlocked when the function returns and this object is destroyed
    boost::interprocess::scoped_lock<boost::mutex> slock(operationMtx);

    //Get the previous operation code and its start time
    uint8_t previousOpCode = opCodeOfLastAction;
    uint32_t previousActionStartTime = actionStartTime;

    //Are we looking for an error string?
    if (req.opCode == OP_GET_ERROR_STRING)
    {
        errorString[0] = '\0';
        expectingErrorString = true;
    }

    bool success = false;
    //For each available attempt
    for (int attemptCount = 0; attemptCount < 1; ++attemptCount)
    {
        //Transmit the packet
        if (attemptCount == 0)
        {
            transmittedPacket = transmitPacket(&(req.opCode), 1, serialPort.get());
        }
        else
        {
            transmittedPacket = retryTransmission(serialPort.get());
        }
        
        acked = false;

        //printf("Transmitted SeqID: %u, CRC16: %u\n", transmittedPacket->sequenceId, transmittedPacket->crc16);

        //Wait for timeout, acknowledgement, or infer communication success from the heartbeat
        ros::Time startWaitTime = ros::Time::now();
        ros::Duration waitTime;
        while (waitTime = ros::Time::now() - startWaitTime, waitTime.toSec() < 0.75)
        {
            if (acked) {
                success = true;
                break;
            }
            if (previousActionStartTime != actionStartTime && opCodeOfLastAction == req.opCode)
            {
                success = true;
                break;
            }
        }
        //Did we succeed? 
        if (success)
        {
            //Don't retry
            break;
        }
    }
    //Did we get a response?
    if (success)
    {
        //Were we looking for an error string?
        if (req.opCode == OP_GET_ERROR_STRING)
        {
            //Wait for the error string packet to arrive
            ros::Time startWaitTime = ros::Time::now();
            ros::Duration waitTime;
            while (expectingErrorString)
            {
                waitTime = ros::Time::now() - startWaitTime;
                if (waitTime.toSec() > 1.0)
                {
                    break;
                }
            }
            //Did we receive it?
            if (expectingErrorString)
            {
                //Successfully transmitted the operation command, but didn't get the error string packet back
                res.errorMessage = "Communication Failure";
            }
            else
            {
                //Successfully transmitted the operation command, and got the error string packet back
                res.errorMessage = std::string(errorString);
            }
        } else {
            //Successfully transmitted the operation command
            res.errorMessage = "";
        }
    }
    else
    {
        //Unsuccessfully transmitted the operation command
        res.errorMessage = "Communication Failure";
    }
    //Return
    expectingErrorString = false;
    acked = true;
    return true;
}

void listenerThread(void)
{
    const Packet* receivedPkt;
    int expectedSequenceNum = -1;
    int numReceivedPackets = 0;
    int numDroppedPackets = 0;

    //Run until interrupted
    ros::Rate r(60);
    ros::Time timeOfLastHeartbeat = ros::Time::now();
    while (ros::ok())
    {
        receivedPkt = checkForPacket(serialPort.get());
        if (receivedPkt != NULL)
        {
            if ( !isAck(receivedPkt) )
            {
                ++numReceivedPackets;
                //Check if we've lost any packets
                if (expectedSequenceNum != -1)
                {
                    while (expectedSequenceNum != receivedPkt->sequenceId)
                    {
                        //printf("Dropped packet %d\n", expectedSequenceNum);
                        expectedSequenceNum =  0xFF & (expectedSequenceNum + 1);
                        ++numDroppedPackets;
                    }
                }
                expectedSequenceNum = 0xFF & (receivedPkt->sequenceId + 1);

                //Compute communication percentage
                double totalPackets = numDroppedPackets + numReceivedPackets;
                //printf("Communication Rate: %f%%\n", (double) numReceivedPackets / totalPackets);

                //Is this a string packet?
                if (receivedPkt->data[receivedPkt->dataLength - 1] == '\0')
                {
                    //printf("String Packet Received: %s\n", receivedPkt->data);
                    //Are we looking for an error string packet?
                    if (expectingErrorString)
                    {
                        strcpy(errorString, (const char*)receivedPkt->data);
                        acked = true;
                        expectingErrorString = false;
                    }
                }
                //Is this a heartbeat packet?
                else if (receivedPkt->dataLength == 36)
                {
                    //Heartbeat packet
                    //printf("Heartbeat Packet Received\n");
                    parseHeartbeatPacket(receivedPkt->data);

                    double timeSinceLastHeartbeat = (ros::Time::now() - timeOfLastHeartbeat).toSec();

                    if (timeSinceLastHeartbeat > 0.3)
                    {
                        std::cout << timeSinceLastHeartbeat << std::endl;
                        printf("Communication Rate: %f%%\n", (double) numReceivedPackets / totalPackets);
                    }

                    //std::cout << (ros::Time::now() - timeOfLastHeartbeat).toSec() << std::endl;
                    timeOfLastHeartbeat = ros::Time::now();
                }
                //This must be some unrecognized binary data packet.
                else
                {
                    //printf("Data Packet Received\n");
                }
            }
            else
            {
                //printf("Ack SeqID: %u, CRC16: %u received\n", receivedPkt->sequenceId, receivedPkt->crc16 );
                //Is this ack acking a packet we sent?
                if (!acked && transmittedPacket != NULL && isAcking(transmittedPacket, receivedPkt))
                {
                    acked = true;
                }
            }
        }
        r.sleep();
    }
}

//Main
int main(int argc, char **argv)
{
    //Create a node
    ros::init(argc, argv, "ball_dropper_node");
    ros::NodeHandle n;

    setMaxAllowedDataLength(36);

    serialPort.reset(new Serial("/dev/ttyUSB0", 9600));

    heartbeatPub = n.advertise<ball_dropper_msgs::Heartbeat>("heartbeat", 100);
    ros::Subscriber consoleSub = n.subscribe("ballDropperMsg", 10, consoleCallback);
    ros::ServiceServer operationService = n.advertiseService("operation", operation);

    std::auto_ptr<boost::thread> pListenerThread;
    //Create a new thread to listen on the serial port.
    pListenerThread.reset( new  boost::thread(listenerThread));

    //Handle subscriber and service server callbacks in this thread
    ros::spin(); 

    pListenerThread->join();

    return 0;
}

